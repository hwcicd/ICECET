[
  {
    "objectID": "slides.html",
    "href": "slides.html",
    "title": "Test, Build, Deploy",
    "section": "",
    "text": "None of us is as smart as all of us.\n\n\nAmber Huffman, Principal Engineer, Google Cloud\n\n\n\n\n\n\n\n\n\n\nWith the collapse of MOSFET scaling circa 2006, higher hardware performance became tightly coupled with higher hardware complexity due to due heat and power constraints.\n\nAlso called “The Heat Wall”\n\nAn explosion of hardware complexity drove major advances in Hardware Design Languages (HDLs).\n\nIn 2009 when IEEE 1364 Verilog standard expanded to inlcude SystemVerilog for software-driven simulation and testing.\n\nThe 2009 “DevOps” formulation of Continuous Integration/Continuous Deployment can be applied to specifications of hardware in HDLs.\n\n\n\n\n\nMajor advances in open source hardware.\n\nRISC-V open source CPUs\nOpenTitan/Caliptra open source root of trust (RoT)\n\nMajor advances in CI/CD formulations for open source hardware\n\nGitHub Actions for CI/CD\nHardware Specification mining for HDLs\n\nWe provide:\n\nA framework to build specifications from HDLs\nA container package to automate the process within workflows."
  },
  {
    "objectID": "slides.html#problem-statement",
    "href": "slides.html#problem-statement",
    "title": "Test, Build, Deploy",
    "section": "",
    "text": "With the collapse of MOSFET scaling circa 2006, higher hardware performance became tightly coupled with higher hardware complexity due to due heat and power constraints.\n\nAlso called “The Heat Wall”\n\nAn explosion of hardware complexity drove major advances in Hardware Design Languages (HDLs).\n\nIn 2009 when IEEE 1364 Verilog standard expanded to inlcude SystemVerilog for software-driven simulation and testing.\n\nThe 2009 “DevOps” formulation of Continuous Integration/Continuous Deployment can be applied to specifications of hardware in HDLs."
  },
  {
    "objectID": "slides.html#state-of-play",
    "href": "slides.html#state-of-play",
    "title": "Test, Build, Deploy",
    "section": "",
    "text": "Major advances in open source hardware.\n\nRISC-V open source CPUs\nOpenTitan/Caliptra open source root of trust (RoT)\n\nMajor advances in CI/CD formulations for open source hardware\n\nGitHub Actions for CI/CD\nHardware Specification mining for HDLs\n\nWe provide:\n\nA framework to build specifications from HDLs\nA container package to automate the process within workflows."
  },
  {
    "objectID": "slides.html#requirements",
    "href": "slides.html#requirements",
    "title": "Test, Build, Deploy",
    "section": "Requirements",
    "text": "Requirements\n\nTestbench\n\nAn HDL “script” to be executed in simulation by a hardware design\n\n\nA way of testing hardware pre-silicon\n\nSimulator\n\nA piece of software that compiles HDL and testbench into a machine executable format\n\nTrace\n\nA transcription of the value of every hardware register at every timepoint while executing some instructions\n\n\nOften stored as a “value change dump” only recording changes for brevity\n\nTranslator\n\nA custom script to convert a hardware trace into a simulated software trace, for software quality tools\n\nMiner\n\nA software quality tool that automatical generates specifications from traces"
  },
  {
    "objectID": "slides.html#specification",
    "href": "slides.html#specification",
    "title": "Test, Build, Deploy",
    "section": "Specification",
    "text": "Specification\n\nSpecify hardware design as rules over registers\n\n\n\n(* Extended Backus–Naur *)\nrule = test | isin | mult | line\n\ntest = reg, eqs, reg\n     | reg, eqs, nat\n\nisin = reg, \"∈ {\", nat, \",\", nat, \"}\"\n     | reg, \"∈ {\", nat, \",\", nat, \",\", nat \"}\"\n\nmult = reg, \"≡ 0 (mod\", reg, \")\"\n\nline = reg, \"+\", reg, \"×\", reg, \n            \"-\", reg, \"+\", nat, \"= 0\"\n\nreg : string\nnat : natural\neqs = \"=\" | \"≠\" | \"&lt;\" | \"⋜\" | \"&gt;\" | \"⋝\"\n\n# Examples\nwr = -1\nwr &lt; trap\nwr ⋜ imem\ntrap ⋝ imem\ntrap ≠ csr\nout ∈ { -1, 0 }\nstatus ∈ { -1, 0, 6144 }\nclk % imem = 0\nclk + 4 * csr - 2 * pc + 3 = 0\n\n-1 denotes a non-numeric hardware value (for uninitalized registers)"
  },
  {
    "objectID": "slides.html#graph-representation",
    "href": "slides.html#graph-representation",
    "title": "Test, Build, Deploy",
    "section": "Graph Representation",
    "text": "Graph Representation"
  },
  {
    "objectID": "slides.html#icarus-verilog-or-iverilog",
    "href": "slides.html#icarus-verilog-or-iverilog",
    "title": "Test, Build, Deploy",
    "section": "Icarus Verilog or iverilog",
    "text": "Icarus Verilog or iverilog\n\niverilog operates much like a compiler over hardware design languages.\n\nSimilar to testing library code, basically.\nDesigns almost always have testbenchs.\n\niverilog is often used for “small projects” but makes IEEE 1364 Value Change Dump (VCD) files.\nASCII encoded description of binary numbers representing numerical values of registers.\n\nHundreds of registers in our minimal examples.\nWe containerized, trimmed build tools but maintained dependencies, and didn’t cache trace data after making specifications."
  },
  {
    "objectID": "slides.html#script",
    "href": "slides.html#script",
    "title": "Test, Build, Deploy",
    "section": "Script",
    "text": "Script\n\n\n\nEarlier research tools have approached translating IEEE 1364 VCD files to other formats but there was no real standard packages.\n\nAs part of this research, we implemented a VCD reader in Python.\n\nThis quickly became a vector for future work and our group is new supporting development of a VCD-to-dataframe family of libraries in Python, R, and Spark.\nSeparately, using a Python script required a Python runtime in our containers.\n\n\n```{.python filename=“rtlkon.py” max-height: 20em} # RTL to Daikon # We do not claim to by Python programmers def rtlkon(filename): name = filename.split(“/”)[-1].split(“.”)[0] fptr = open(filename, “r”) line = “” nonce = 1 while “\\(scope\" not in line:\n        line = fptr.readline()\n    vars = get_vars(fptr)\n    vars_to_decls(vars, name)\n    vals = {var: -1 for var in vars}\n    while \"\\)dumpvars” not in fptr.readline(): pass dptr = open(name + “.dtrace”, “w”) while line: line, vals = tick(fptr, vals) vals_to_dtrace(vars, vals, nonce, dptr) nonce += 1\ndef get_vars(fptr): line = fptr.readline() vars = {} # just hope it stays ordered while “$enddefinitions” not in line: if “var” in line: parts = line.split() if parts[4] not in vars.values(): vars[parts[3]] = parts[4] line = fptr.readline() return vars\ndef vars_to_decls(vars, name): f = open(name + “.decls”, “w”) def vars_to_tick(vars): for var in vars.values(): f.write(” variable ” + var + ““” var-kind variable rep-type int dec-type int comparability 1“““) f.write(”input-language C/C++-version 2.0” + “var-comparability implicit..tick():::ENTER” + ” ppt-type enter“) vars_to_tick(vars)\nf.write(”..tick():::EXIT0” + ” ppt-type subexit“) vars_to_tick(vars)\ndef tick(fptr, vals): line = fptr.readline() while line and “#” != line[0]: # Two cases, words and bits if ” ” in line: # word val, var = line[1:].strip().split() else: # bit val, var = line[0], line[1:].strip() if var in vals: vals[var] = int(val, 2) if val.isdigit() else -1 line = fptr.readline() return line, vals\ndef vals_to_dtrace(vars, vals, nonce, dptr): dptr.write(“..tick():::ENTER_invocation_nonce” + str(nonce) + “”) [dptr.write(vars[var] + “” + str(vals[var]) + “”) for var in vars] dptr.write(“”) dptr.write(“..tick():::EXIT0_invocation_nonce” + str(nonce) + “”) [dptr.write(vars[var] + “” + str(vals[var]) + “”) for var in vars] dptr.write(“”)\nif name == “main”: import sys rtlkon(sys.argv[1]) ```\n\n-1 denotes a non-numeric hardware value (for uninitalized registers)"
  },
  {
    "objectID": "slides.html#daikon",
    "href": "slides.html#daikon",
    "title": "Test, Build, Deploy",
    "section": "Daikon",
    "text": "Daikon"
  },
  {
    "objectID": "slides.html#picorv32",
    "href": "slides.html#picorv32",
    "title": "Test, Build, Deploy",
    "section": "PicoRV32",
    "text": "PicoRV32"
  },
  {
    "objectID": "slides.html#holdouts",
    "href": "slides.html#holdouts",
    "title": "Test, Build, Deploy",
    "section": "Holdouts",
    "text": "Holdouts"
  },
  {
    "objectID": "slides.html#performance",
    "href": "slides.html#performance",
    "title": "Test, Build, Deploy",
    "section": "Performance",
    "text": "Performance"
  },
  {
    "objectID": "slides.rjs.html#problem-statement",
    "href": "slides.rjs.html#problem-statement",
    "title": "Test, Build, Deploy",
    "section": "Problem Statement",
    "text": "Problem Statement\n\nWith the collapse of MOSFET scaling circa 2006, higher hardware performance became tightly coupled with higher hardware complexity due to due heat and power constraints.\n\nAlso called “The Heat Wall”\n\nAn explosion of hardware complexity drove major advances in Hardware Design Languages (HDLs).\n\nIn 2009 when IEEE 1364 Verilog standard expanded to inlcude SystemVerilog for software-driven simulation and testing.\n\nThe 2009 “DevOps” formulation of Continuous Integration/Continuous Deployment can be applied to specifications of hardware in HDLs."
  },
  {
    "objectID": "slides.rjs.html#state-of-play",
    "href": "slides.rjs.html#state-of-play",
    "title": "Test, Build, Deploy",
    "section": "State of Play",
    "text": "State of Play\n\nMajor advances in open source hardware.\n\nRISC-V open source CPUs\nOpenTitan/Caliptra open source root of trust (RoT)\n\nMajor advances in CI/CD formulations for open source hardware\n\nGitHub Actions for CI/CD\nHardware Specification mining for HDLs\n\nWe provide:\n\nA framework to build specifications from HDLs\nA container package to automate the process within workflows."
  },
  {
    "objectID": "slides.rjs.html#requirements",
    "href": "slides.rjs.html#requirements",
    "title": "Test, Build, Deploy",
    "section": "Requirements",
    "text": "Requirements\n\nTestbench\n\nAn HDL “script” to be executed in simulation by a hardware design\n\n\nA way of testing hardware pre-silicon\n\nSimulator\n\nA piece of software that compiles HDL and testbench into a machine executable format\n\nTrace\n\nA transcription of the value of every hardware register at every timepoint while executing some instructions\n\n\nOften stored as a “value change dump” only recording changes for brevity\n\nTranslator\n\nA custom script to convert a hardware trace into a simulated software trace, for software quality tools\n\nMiner\n\nA software quality tool that automatical generates specifications from traces"
  },
  {
    "objectID": "slides.rjs.html#specification",
    "href": "slides.rjs.html#specification",
    "title": "Test, Build, Deploy",
    "section": "Specification",
    "text": "Specification\n\nSpecify hardware design as rules over registers\n\n\n\n(* Extended Backus–Naur *)\nrule = test | isin | mult | line\n\ntest = reg, eqs, reg\n     | reg, eqs, nat\n\nisin = reg, \"∈ {\", nat, \",\", nat, \"}\"\n     | reg, \"∈ {\", nat, \",\", nat, \",\", nat \"}\"\n\nmult = reg, \"≡ 0 (mod\", reg, \")\"\n\nline = reg, \"+\", reg, \"×\", reg, \n            \"-\", reg, \"+\", nat, \"= 0\"\n\nreg : string\nnat : natural\neqs = \"=\" | \"≠\" | \"&lt;\" | \"⋜\" | \"&gt;\" | \"⋝\"\n\n# Examples\nwr = -1\nwr &lt; trap\nwr ⋜ imem\ntrap ⋝ imem\ntrap ≠ csr\nout ∈ { -1, 0 }\nstatus ∈ { -1, 0, 6144 }\nclk % imem = 0\nclk + 4 * csr - 2 * pc + 3 = 0\n\n-1 denotes a non-numeric hardware value (for uninitalized registers)"
  },
  {
    "objectID": "slides.rjs.html#graph-representation",
    "href": "slides.rjs.html#graph-representation",
    "title": "Test, Build, Deploy",
    "section": "Graph Representation",
    "text": "Graph Representation"
  },
  {
    "objectID": "slides.rjs.html#icarus-verilog-or-iverilog",
    "href": "slides.rjs.html#icarus-verilog-or-iverilog",
    "title": "Test, Build, Deploy",
    "section": "Icarus Verilog or iverilog",
    "text": "Icarus Verilog or iverilog\n\niverilog operates much like a compiler over hardware design languages.\n\nSimilar to testing library code, basically.\nDesigns almost always have testbenchs.\n\niverilog is often used for “small projects” but makes IEEE 1364 Value Change Dump (VCD) files.\nASCII encoded description of binary numbers representing numerical values of registers.\n\nHundreds of registers in our minimal examples.\nWe containerized, trimmed build tools but maintained dependencies, and didn’t cache trace data after making specifications."
  },
  {
    "objectID": "slides.rjs.html#script",
    "href": "slides.rjs.html#script",
    "title": "Test, Build, Deploy",
    "section": "Script",
    "text": "Script\n\n\n\nEarlier research tools have approached translating IEEE 1364 VCD files to other formats but there was no real standard packages.\n\nAs part of this research, we implemented a VCD reader in Python.\n\nThis quickly became a vector for future work and our group is new supporting development of a VCD-to-dataframe family of libraries in Python, R, and Spark.\nSeparately, using a Python script required a Python runtime in our containers.\n\n\n```{.python filename=“rtlkon.py” max-height: 20em} # RTL to Daikon # We do not claim to by Python programmers def rtlkon(filename): name = filename.split(“/”)[-1].split(“.”)[0] fptr = open(filename, “r”) line = “” nonce = 1 while “\\(scope\" not in line:\n        line = fptr.readline()\n    vars = get_vars(fptr)\n    vars_to_decls(vars, name)\n    vals = {var: -1 for var in vars}\n    while \"\\)dumpvars” not in fptr.readline(): pass dptr = open(name + “.dtrace”, “w”) while line: line, vals = tick(fptr, vals) vals_to_dtrace(vars, vals, nonce, dptr) nonce += 1\ndef get_vars(fptr): line = fptr.readline() vars = {} # just hope it stays ordered while “$enddefinitions” not in line: if “var” in line: parts = line.split() if parts[4] not in vars.values(): vars[parts[3]] = parts[4] line = fptr.readline() return vars\ndef vars_to_decls(vars, name): f = open(name + “.decls”, “w”) def vars_to_tick(vars): for var in vars.values(): f.write(” variable ” + var + ““” var-kind variable rep-type int dec-type int comparability 1“““) f.write(”input-language C/C++-version 2.0” + “var-comparability implicit..tick():::ENTER” + ” ppt-type enter“) vars_to_tick(vars)\nf.write(”..tick():::EXIT0” + ” ppt-type subexit“) vars_to_tick(vars)\ndef tick(fptr, vals): line = fptr.readline() while line and “#” != line[0]: # Two cases, words and bits if ” ” in line: # word val, var = line[1:].strip().split() else: # bit val, var = line[0], line[1:].strip() if var in vals: vals[var] = int(val, 2) if val.isdigit() else -1 line = fptr.readline() return line, vals\ndef vals_to_dtrace(vars, vals, nonce, dptr): dptr.write(“..tick():::ENTER_invocation_nonce” + str(nonce) + “”) [dptr.write(vars[var] + “” + str(vals[var]) + “”) for var in vars] dptr.write(“”) dptr.write(“..tick():::EXIT0_invocation_nonce” + str(nonce) + “”) [dptr.write(vars[var] + “” + str(vals[var]) + “”) for var in vars] dptr.write(“”)\nif name == “main”: import sys rtlkon(sys.argv[1]) ```\n\n-1 denotes a non-numeric hardware value (for uninitalized registers)"
  },
  {
    "objectID": "slides.rjs.html#daikon",
    "href": "slides.rjs.html#daikon",
    "title": "Test, Build, Deploy",
    "section": "Daikon",
    "text": "Daikon"
  },
  {
    "objectID": "slides.rjs.html#picorv32",
    "href": "slides.rjs.html#picorv32",
    "title": "Test, Build, Deploy",
    "section": "PicoRV32",
    "text": "PicoRV32"
  },
  {
    "objectID": "slides.rjs.html#holdouts",
    "href": "slides.rjs.html#holdouts",
    "title": "Test, Build, Deploy",
    "section": "Holdouts",
    "text": "Holdouts"
  },
  {
    "objectID": "slides.rjs.html#performance",
    "href": "slides.rjs.html#performance",
    "title": "Test, Build, Deploy",
    "section": "Performance",
    "text": "Performance"
  }
]