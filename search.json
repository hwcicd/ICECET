[
  {
    "objectID": "slides.html",
    "href": "slides.html",
    "title": "Test, Build, Deploy",
    "section": "",
    "text": "github.com/hwcicd/ICECET"
  },
  {
    "objectID": "slides.html#follow-along",
    "href": "slides.html#follow-along",
    "title": "Test, Build, Deploy",
    "section": "",
    "text": "github.com/hwcicd/ICECET"
  },
  {
    "objectID": "slides.html#problem-statement",
    "href": "slides.html#problem-statement",
    "title": "Test, Build, Deploy",
    "section": "Problem Statement",
    "text": "Problem Statement\n\nWith the collapse of MOSFET scaling circa 2006, higher hardware performance became tightly coupled with higher hardware complexity due to due heat and power constraints.\n\nAlso called “The Heat Wall”\n\nAn explosion of hardware complexity drove major advances in Hardware Design Languages (HDLs).\n\nIn 2009 when IEEE 1364 Verilog standard expanded to inlcude SystemVerilog for software-driven simulation and testing.\n\nThe 2009 “DevOps” formulation of Continuous Integration/Continuous Deployment can be applied to specifications of hardware in HDLs."
  },
  {
    "objectID": "slides.html#state-of-play",
    "href": "slides.html#state-of-play",
    "title": "Test, Build, Deploy",
    "section": "State of Play",
    "text": "State of Play\n\nMajor advances in open source hardware.\n\nRISC-V open source CPUs\nOpenTitan/Caliptra open source root of trust (RoT)\n\nMajor advances in CI/CD formulations for open source hardware\n\nGitHub Actions for CI/CD\nHardware Specification mining for HDLs\n\nWe provide:\n\nA framework to build specifications from HDLs\nA container package to automate the process within workflows."
  },
  {
    "objectID": "slides.html#requirements",
    "href": "slides.html#requirements",
    "title": "Test, Build, Deploy",
    "section": "Requirements",
    "text": "Requirements\n\nTestbench\n\nAn HDL “script” to be executed in simulation by a hardware design\n\n\nA way of testing hardware pre-silicon\n\nSimulator\n\nA piece of software that compiles HDL and testbench into a machine executable format\n\nTrace\n\nA transcription of the value of every hardware register at every timepoint while executing some instructions\n\n\nOften stored as a “value change dump” only recording changes for brevity\n\nTranslator\n\nA custom script to convert a hardware trace into a simulated software trace, for software quality tools\n\nMiner\n\nA software quality tool that automatical generates specifications from traces"
  },
  {
    "objectID": "slides.html#specification",
    "href": "slides.html#specification",
    "title": "Test, Build, Deploy",
    "section": "Specification",
    "text": "Specification\n\nSpecify hardware design as rules over registers\n\n\n\n(* Extended Backus–Naur *)\n\nrule = test | isin | mult | line\n\ntest = reg, eqs, reg\n     | reg, eqs, nat\n\nisin = reg, \"∈ {\", nat, \",\", nat, \"}\"\n     | reg, \"∈ {\", nat, \",\", nat, \",\", nat \"}\"\n\nmult = reg, \"≡ 0 (mod\", reg, \")\"\n\nline = reg, \"+\", reg, \"×\", reg, \n            \"-\", reg, \"+\", nat, \"= 0\"\n\nreg : string\nnat : natural\neqs = \"=\" | \"≠\" | \"&lt;\" | \"⋜\" | \"&gt;\" | \"⋝\"\n\n# Examples\n\nwr = -1\nwr &lt; trap\nwr ⋜ imem\ntrap ⋝ imem\ntrap ≠ csr\nout ∈ { -1, 0 }\nstatus ∈ { -1, 0, 6144 }\nclk % imem = 0\nclk + 4 * csr - 2 * pc + 3 = 0\n\n-1 denotes a non-numeric hardware value (for uninitalized registers)"
  },
  {
    "objectID": "slides.html#graph-representation",
    "href": "slides.html#graph-representation",
    "title": "Test, Build, Deploy",
    "section": "Graph Representation",
    "text": "Graph Representation\n\nWe term this the “Myrtha” package."
  },
  {
    "objectID": "slides.html#icarus-verilog-or-iverilog",
    "href": "slides.html#icarus-verilog-or-iverilog",
    "title": "Test, Build, Deploy",
    "section": "Icarus Verilog or iverilog",
    "text": "Icarus Verilog or iverilog\n\niverilog operates much like a compiler over hardware design languages.\n\nSimilar to testing library code, basically.\nDesigns almost always have testbenchs.\n\niverilog is often used for “small projects” but makes IEEE 1364 Value Change Dump (VCD) files.\nASCII encoded description of binary numbers representing numerical values of registers.\n\nHundreds of registers in our minimal examples.\nWe containerized, trimmed build tools but maintained dependencies, and didn’t cache trace data after making specifications."
  },
  {
    "objectID": "slides.html#translation-algorithm",
    "href": "slides.html#translation-algorithm",
    "title": "Test, Build, Deploy",
    "section": "Translation Algorithm",
    "text": "Translation Algorithm\nHow do we go from value changes to traces?\n\nTraverse to the enumeration of registers.\nInstantiate a data structure to store registers and values.\nWrite registers to a Daikon “declarations” file. (.decls)\nTraverse to value changes.\nFor each time point:\n\nRead each line, updating current register value.\nAppend current values to a Daikon “trace” file. (.dtrace)"
  },
  {
    "objectID": "slides.html#daikon",
    "href": "slides.html#daikon",
    "title": "Test, Build, Deploy",
    "section": "Daikon",
    "text": "Daikon\n\nWe regard Daikon as an example of a state-of-the-art specification miner.\nAs doi:10.1016/j.scico.2007.01.015, Daikon has ~1600 citations.\nIntended for use in Java\n\nModel registers as software level variables\nModel time slices (usually some number of nanoseconds) as methods.\n\n\n\n\n`timescale 1 ns / 1 ps\n\nmodule acw #\n(\n  //-- base address\n  input wire[31 : 0] r_base_addr_wire,\n  input wire[31 : 0] w_base_addr_wire,\n  //-- num transaction\n  input wire[15 : 0] r_num_trans_wire,\n  input wire[15 : 0] w_num_trans_wire,\n  ...\n\npublic class Main {\n\n static void acw() {\n\n  //-- base address\n  long r_base_addr_wire; // long to get 64 bits\n  long w_base_addr_wire; // (32 data + room for -1)\n  //-- num transaction\n  int r_num_trans_wire; \n  int w_num_trans_wire; \n  ..."
  },
  {
    "objectID": "slides.html#podman-and-github-actions",
    "href": "slides.html#podman-and-github-actions",
    "title": "Test, Build, Deploy",
    "section": "Podman and GitHub Actions",
    "text": "Podman and GitHub Actions\n\nWe fully automate the whole process with Makefiles, a CI/CD container, and GitHub actions.\nSpecifications are generally generated in around 40 seconds over our 100-1000 register size designs on commit.\n\nAround 4 seconds locally - so most time is spent spinning up our image.\nAround ~70 KB in size.\n\nMakefiles tend to be 1-10 lines of code\nThe Containerfile, Python script, and GitHub YAML are 10-100.\nOur container was ~1.7 GB."
  },
  {
    "objectID": "slides.html#picorv32",
    "href": "slides.html#picorv32",
    "title": "Test, Build, Deploy",
    "section": "PicoRV32",
    "text": "PicoRV32\n\nA 32 bit processor implementing the RV32I (RISC-V Integer) instruction set architecture (ISA) standard with optional Multiply and Divide (M) and Compressed (C) extensions.\nBasically a minimal full-featured processor design suitable for FPGA or ASIC.\n\n\n\n\nPicoRV32 size\n\n232 registers\n3049 lines of Verilog\n\nTestbench size\n\n2201 cycles\n86 lines of Verilog\n\n\n\n\nTrace and specification size\n\n\n\n\n\nlines\nwords\nbytes\n\n\n\n\n.vcd\n30356\n46200\n269184\n\n\n.decls\n2219\n4434\n39059\n\n\n.dtrace\n2936134\n2931732\n17474090\n\n\nspec\n1846\n5780\n71988"
  },
  {
    "objectID": "slides.html#holdouts",
    "href": "slides.html#holdouts",
    "title": "Test, Build, Deploy",
    "section": "Holdouts",
    "text": "Holdouts\n\nTo evaluate (1) Generalizability and (2) Performance we checked our framework on two other designs.\n\nNERV - Another RISC-V core\nAKER - An AXI access control module.\n\nWe had to modify one line in the Containerfile (and rebuild for 5 minutes) for AKER and add one line to our Makefile to support SystemVerilog extensions but made no other changes.\nWe regard this as a successful proof of concept, and are now seeking partners with larger designs and more powerful compute resources to evaluate scaling.\n\n\nWe believe specification generation time scales linearly with the product of trace length and number of registers, and specification size scales with the log of the product."
  },
  {
    "objectID": "slides.html#performance",
    "href": "slides.html#performance",
    "title": "Test, Build, Deploy",
    "section": "Performance",
    "text": "Performance\n\n\n\nNERV size\n\n549 registers\n1267 lines of Verilog\n\nTestbench size\n\n19 cycles\n155 lines of SystemVerilog\n\nTrace and specification size\n\n\n\n\n\nlines\nwords\nbytes\n\n\n\n\n.vcd\n30356\n46200\n269184\n\n\n.decls\n2219\n4434\n39059\n\n\n.dtrace\n2936134\n2931732\n17474090\n\n\nspec\n1846\n5780\n71988\n\n\n\n\n\nAKER size\n\n432 registers\n2002 lines of Verilog\n\nTestbench size\n\n1055 cycles\n527 lines of SystemVerilog\n\nTrace and specification size\n\n\n\n\n\nlines\nwords\nbytes\n\n\n\n\n.vcd\n6290\n10990\n53007\n\n\n.decls\n3519\n7034\n62829\n\n\n.dtrace\n2230270\n2228160\n13840288\n\n\nspec\n5594\n17986\n181149"
  },
  {
    "objectID": "slides.html#contributions",
    "href": "slides.html#contributions",
    "title": "Test, Build, Deploy",
    "section": "Contributions",
    "text": "Contributions\n\nGeneralizable and autonomous verilog-to-specification pipeline for hardware designs.\nManagable container size for options for trimming.\nLinear time and log space complexity with product design size and test duration.\nGPLv3 tested-and-documented code."
  },
  {
    "objectID": "slides.html#future-work",
    "href": "slides.html#future-work",
    "title": "Test, Build, Deploy",
    "section": "Future Work",
    "text": "Future Work\n\nWe have upgraded the custom Python script to a Python/Spark/R package which reads VCDs to various binary formats.\n\nUp to 100x space savings versus .decls + .dtrace\nAccepted at ACDSA’25\nAvailable as vcd2df on arXiv, CRAN, PyPI\n\nUsing Spark, we have parallelized the process to hundreds of traces.\n\nWe used this to study information flow paths that may reveal transient execution CPU vulnerabilities (Spectre/Meltdown/etc)\n\nWe are exploring specification mining in Rust or Python to remove the JVM/ASCII bottleneck and scale to larger designs.\n\nNamely BOOM core, an open source RISC-V design with a Spectre vulnerability."
  },
  {
    "objectID": "slides.html#questions",
    "href": "slides.html#questions",
    "title": "Test, Build, Deploy",
    "section": "Questions",
    "text": "Questions\n\nAsk me about:\n\nGitHub Actions/Workflows\nUsing the tool on NERV\n\nEmail cdeutschbein@willamette.edu about:\n\nSpecification mining\nArchitecture\nComplexity"
  },
  {
    "objectID": "slides.rjs.html#follow-along",
    "href": "slides.rjs.html#follow-along",
    "title": "Test, Build, Deploy",
    "section": "Follow Along",
    "text": "Follow Along\ngithub.com/hwcicd/ICECET"
  },
  {
    "objectID": "slides.rjs.html#problem-statement",
    "href": "slides.rjs.html#problem-statement",
    "title": "Test, Build, Deploy",
    "section": "Problem Statement",
    "text": "Problem Statement\n\nWith the collapse of MOSFET scaling circa 2006, higher hardware performance became tightly coupled with higher hardware complexity due to due heat and power constraints.\n\nAlso called “The Heat Wall”\n\nAn explosion of hardware complexity drove major advances in Hardware Design Languages (HDLs).\n\nIn 2009 when IEEE 1364 Verilog standard expanded to inlcude SystemVerilog for software-driven simulation and testing.\n\nThe 2009 “DevOps” formulation of Continuous Integration/Continuous Deployment can be applied to specifications of hardware in HDLs."
  },
  {
    "objectID": "slides.rjs.html#state-of-play",
    "href": "slides.rjs.html#state-of-play",
    "title": "Test, Build, Deploy",
    "section": "State of Play",
    "text": "State of Play\n\nMajor advances in open source hardware.\n\nRISC-V open source CPUs\nOpenTitan/Caliptra open source root of trust (RoT)\n\nMajor advances in CI/CD formulations for open source hardware\n\nGitHub Actions for CI/CD\nHardware Specification mining for HDLs\n\nWe provide:\n\nA framework to build specifications from HDLs\nA container package to automate the process within workflows."
  },
  {
    "objectID": "slides.rjs.html#requirements",
    "href": "slides.rjs.html#requirements",
    "title": "Test, Build, Deploy",
    "section": "Requirements",
    "text": "Requirements\n\nTestbench\n\nAn HDL “script” to be executed in simulation by a hardware design\n\n\nA way of testing hardware pre-silicon\n\nSimulator\n\nA piece of software that compiles HDL and testbench into a machine executable format\n\nTrace\n\nA transcription of the value of every hardware register at every timepoint while executing some instructions\n\n\nOften stored as a “value change dump” only recording changes for brevity\n\nTranslator\n\nA custom script to convert a hardware trace into a simulated software trace, for software quality tools\n\nMiner\n\nA software quality tool that automatical generates specifications from traces"
  },
  {
    "objectID": "slides.rjs.html#specification",
    "href": "slides.rjs.html#specification",
    "title": "Test, Build, Deploy",
    "section": "Specification",
    "text": "Specification\n\nSpecify hardware design as rules over registers\n\n\n\n(* Extended Backus–Naur *)\n\nrule = test | isin | mult | line\n\ntest = reg, eqs, reg\n     | reg, eqs, nat\n\nisin = reg, \"∈ {\", nat, \",\", nat, \"}\"\n     | reg, \"∈ {\", nat, \",\", nat, \",\", nat \"}\"\n\nmult = reg, \"≡ 0 (mod\", reg, \")\"\n\nline = reg, \"+\", reg, \"×\", reg, \n            \"-\", reg, \"+\", nat, \"= 0\"\n\nreg : string\nnat : natural\neqs = \"=\" | \"≠\" | \"&lt;\" | \"⋜\" | \"&gt;\" | \"⋝\"\n\n# Examples\n\nwr = -1\nwr &lt; trap\nwr ⋜ imem\ntrap ⋝ imem\ntrap ≠ csr\nout ∈ { -1, 0 }\nstatus ∈ { -1, 0, 6144 }\nclk % imem = 0\nclk + 4 * csr - 2 * pc + 3 = 0\n\n-1 denotes a non-numeric hardware value (for uninitalized registers)"
  },
  {
    "objectID": "slides.rjs.html#graph-representation",
    "href": "slides.rjs.html#graph-representation",
    "title": "Test, Build, Deploy",
    "section": "Graph Representation",
    "text": "Graph Representation\n\nWe term this the “Myrtha” package."
  },
  {
    "objectID": "slides.rjs.html#icarus-verilog-or-iverilog",
    "href": "slides.rjs.html#icarus-verilog-or-iverilog",
    "title": "Test, Build, Deploy",
    "section": "Icarus Verilog or iverilog",
    "text": "Icarus Verilog or iverilog\n\niverilog operates much like a compiler over hardware design languages.\n\nSimilar to testing library code, basically.\nDesigns almost always have testbenchs.\n\niverilog is often used for “small projects” but makes IEEE 1364 Value Change Dump (VCD) files.\nASCII encoded description of binary numbers representing numerical values of registers.\n\nHundreds of registers in our minimal examples.\nWe containerized, trimmed build tools but maintained dependencies, and didn’t cache trace data after making specifications."
  },
  {
    "objectID": "slides.rjs.html#translation-algorithm",
    "href": "slides.rjs.html#translation-algorithm",
    "title": "Test, Build, Deploy",
    "section": "Translation Algorithm",
    "text": "Translation Algorithm\nHow do we go from value changes to traces?\n\nTraverse to the enumeration of registers.\nInstantiate a data structure to store registers and values.\nWrite registers to a Daikon “declarations” file. (.decls)\nTraverse to value changes.\nFor each time point:\n\nRead each line, updating current register value.\nAppend current values to a Daikon “trace” file. (.dtrace)"
  },
  {
    "objectID": "slides.rjs.html#daikon",
    "href": "slides.rjs.html#daikon",
    "title": "Test, Build, Deploy",
    "section": "Daikon",
    "text": "Daikon\n\nWe regard Daikon as an example of a state-of-the-art specification miner.\nAs doi:10.1016/j.scico.2007.01.015, Daikon has ~1600 citations.\nIntended for use in Java\n\nModel registers as software level variables\nModel time slices (usually some number of nanoseconds) as methods.\n\n\n\n\n`timescale 1 ns / 1 ps\n\nmodule acw #\n(\n  //-- base address\n  input wire[31 : 0] r_base_addr_wire,\n  input wire[31 : 0] w_base_addr_wire,\n  //-- num transaction\n  input wire[15 : 0] r_num_trans_wire,\n  input wire[15 : 0] w_num_trans_wire,\n  ...\n\npublic class Main {\n\n static void acw() {\n\n  //-- base address\n  long r_base_addr_wire; // long to get 64 bits\n  long w_base_addr_wire; // (32 data + room for -1)\n  //-- num transaction\n  int r_num_trans_wire; \n  int w_num_trans_wire; \n  ..."
  },
  {
    "objectID": "slides.rjs.html#podman-and-github-actions",
    "href": "slides.rjs.html#podman-and-github-actions",
    "title": "Test, Build, Deploy",
    "section": "Podman and GitHub Actions",
    "text": "Podman and GitHub Actions\n\nWe fully automate the whole process with Makefiles, a CI/CD container, and GitHub actions.\nSpecifications are generally generated in around 40 seconds over our 100-1000 register size designs on commit.\n\nAround 4 seconds locally - so most time is spent spinning up our image.\nAround ~70 KB in size.\n\nMakefiles tend to be 1-10 lines of code\nThe Containerfile, Python script, and GitHub YAML are 10-100.\nOur container was ~1.7 GB."
  },
  {
    "objectID": "slides.rjs.html#picorv32",
    "href": "slides.rjs.html#picorv32",
    "title": "Test, Build, Deploy",
    "section": "PicoRV32",
    "text": "PicoRV32\n\nA 32 bit processor implementing the RV32I (RISC-V Integer) instruction set architecture (ISA) standard with optional Multiply and Divide (M) and Compressed (C) extensions.\nBasically a minimal full-featured processor design suitable for FPGA or ASIC.\n\n\n\n\nPicoRV32 size\n\n232 registers\n3049 lines of Verilog\n\nTestbench size\n\n2201 cycles\n86 lines of Verilog\n\n\n\n\nTrace and specification size\n\n\n\n\n\nlines\nwords\nbytes\n\n\n\n\n.vcd\n30356\n46200\n269184\n\n\n.decls\n2219\n4434\n39059\n\n\n.dtrace\n2936134\n2931732\n17474090\n\n\nspec\n1846\n5780\n71988"
  },
  {
    "objectID": "slides.rjs.html#holdouts",
    "href": "slides.rjs.html#holdouts",
    "title": "Test, Build, Deploy",
    "section": "Holdouts",
    "text": "Holdouts\n\nTo evaluate (1) Generalizability and (2) Performance we checked our framework on two other designs.\n\nNERV - Another RISC-V core\nAKER - An AXI access control module.\n\nWe had to modify one line in the Containerfile (and rebuild for 5 minutes) for AKER and add one line to our Makefile to support SystemVerilog extensions but made no other changes.\nWe regard this as a successful proof of concept, and are now seeking partners with larger designs and more powerful compute resources to evaluate scaling.\n\n\nWe believe specification generation time scales linearly with the product of trace length and number of registers, and specification size scales with the log of the product."
  },
  {
    "objectID": "slides.rjs.html#performance",
    "href": "slides.rjs.html#performance",
    "title": "Test, Build, Deploy",
    "section": "Performance",
    "text": "Performance\n\n\n\nNERV size\n\n549 registers\n1267 lines of Verilog\n\nTestbench size\n\n19 cycles\n155 lines of SystemVerilog\n\nTrace and specification size\n\n\n\n\n\nlines\nwords\nbytes\n\n\n\n\n.vcd\n30356\n46200\n269184\n\n\n.decls\n2219\n4434\n39059\n\n\n.dtrace\n2936134\n2931732\n17474090\n\n\nspec\n1846\n5780\n71988\n\n\n\n\n\nAKER size\n\n432 registers\n2002 lines of Verilog\n\nTestbench size\n\n1055 cycles\n527 lines of SystemVerilog\n\nTrace and specification size\n\n\n\n\n\nlines\nwords\nbytes\n\n\n\n\n.vcd\n6290\n10990\n53007\n\n\n.decls\n3519\n7034\n62829\n\n\n.dtrace\n2230270\n2228160\n13840288\n\n\nspec\n5594\n17986\n181149"
  },
  {
    "objectID": "slides.rjs.html#contributions",
    "href": "slides.rjs.html#contributions",
    "title": "Test, Build, Deploy",
    "section": "Contributions",
    "text": "Contributions\n\nGeneralizable and autonomous verilog-to-specification pipeline for hardware designs.\nManagable container size for options for trimming.\nLinear time and log space complexity with product design size and test duration.\nGPLv3 tested-and-documented code."
  },
  {
    "objectID": "slides.rjs.html#future-work",
    "href": "slides.rjs.html#future-work",
    "title": "Test, Build, Deploy",
    "section": "Future Work",
    "text": "Future Work\n\nWe have upgraded the custom Python script to a Python/Spark/R package which reads VCDs to various binary formats.\n\nUp to 100x space savings versus .decls + .dtrace\nAccepted at ACDSA’25\nAvailable as vcd2df on arXiv, CRAN, PyPI\n\nUsing Spark, we have parallelized the process to hundreds of traces.\n\nWe used this to study information flow paths that may reveal transient execution CPU vulnerabilities (Spectre/Meltdown/etc)\n\nWe are exploring specification mining in Rust or Python to remove the JVM/ASCII bottleneck and scale to larger designs.\n\nNamely BOOM core, an open source RISC-V design with a Spectre vulnerability."
  },
  {
    "objectID": "slides.rjs.html#questions",
    "href": "slides.rjs.html#questions",
    "title": "Test, Build, Deploy",
    "section": "Questions",
    "text": "Questions\n\nAsk me about:\n\nGitHub Actions/Workflows\nUsing the tool on NERV\n\nEmail cdeutschbein@willamette.edu about:\n\nSpecification mining\nArchitecture\nComplexity"
  }
]